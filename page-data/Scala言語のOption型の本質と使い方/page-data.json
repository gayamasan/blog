{"componentChunkName":"component---src-templates-blog-post-js","path":"/Scala言語のOption型の本質と使い方/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","excerpt":"Option 型のポイント Option 型の本質 プログラミング中で Option 型に遭遇した場合は、次の 2 つの解釈ができます。1 つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合は Some となり、値が存在しない場合は None となります。…","html":"<h2>Option 型のポイント</h2>\n<h3>Option 型の本質</h3>\n<p>プログラミング中で Option 型に遭遇した場合は、次の 2 つの解釈ができます。1 つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合は Some となり、値が存在しない場合は None となります。2 つ目は、例外ハンドリング結果を表現したものです。正常に実行できた場合は Some となり、プログラムの実行中に意図した例外が発生した場合に None となります。</p>\n<h3>単一の Option 型の値に対して処理をしたいとき</h3>\n<p>初心者がやりがちなのは、Option 型の値を取り出そうとすることですが、これは誤った発想です。代わりに、Option 型の値を変換する発想が必要です。Option 型の値を変換するには、map コンビネーターを使用することで実現できます。また、他にも Option 型から値を取り出さずに処理を行うコンビネーターが提供されていますので、こちらを使用することをおすすめします。ただし最終的にはどこかのタイミングで Option 型から値を取り出す必要がありますが、可能な限りそのタイミングは遅らせるべきです。</p>\n<h3>複数の Option 型の値に対して処理をしたいとき</h3>\n<p>初心者が陥りやすいのは、2 つの Option 型に対して処理をした結果、戻りの型が <code class=\"language-text\">Option[Option[T]]</code> のようにネストしてしまうことです。しかし、このネストしたものが表現するパターンは、以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側の Option</th>\n<th align=\"center\">内側の Option</th>\n<th align=\"center\">実質的に値があるかどうか</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">Some</td>\n<td align=\"center\">ある（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">None</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n<tr>\n<td align=\"center\">None</td>\n<td align=\"center\">-</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n<tr>\n<td align=\"center\">None</td>\n<td align=\"center\">-</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n</tbody>\n</table>\n<p>また、Option 型には別の解釈方法もあり、最大要素数が 1 のコレクションとして捉えることができます。この場合、<code class=\"language-text\">Option[Option[T]]</code>の全体の要素数は以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側の要素数</th>\n<th align=\"center\">内側の要素数</th>\n<th align=\"center\">全体の要素数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0（None）</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0（None）</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0（None）</td>\n</tr>\n</tbody>\n</table>\n<p>つまり、実質的には Some か None の 2 通りしかありませんので、<code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> と平坦化することが望ましいです。この平坦化を実現するには、flatMap コンビネーターを使用することで簡単に実現できます。</p>\n<p>実務的には、まずは map コンビネーターを使って処理をしてみて、戻り値が <code class=\"language-text\">Option[Option[T]]</code> のようになってしまった場合は、外側の map を flatMap に変更することで解決できます。</p>\n<p>このように <code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> に変換できる性質を含めた抽象化された概念をモナドと呼びます。つまり、flatMap とはモナドという概念を表していることになります。</p>\n<h3>for 式と flatMap の関係</h3>\n<p>初心者が誤解しやすいのは、Scala の for 式をループ処理の指定だと勘違いしていることです。しかし、Scala の for 式においてはその発想をまず捨ててください。for 式の本質は flatMap の書き換えであり、ループ処理ではありません。flatMap の階層が深くなってきた場合には、for 式に書き換えることをおすすめします。</p>\n<p>以下に Option 型に対して for 式を適用した具体例を示します。</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> iOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> jOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> kOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// flatMapで平坦化</span>\n<span class=\"token keyword\">val</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  iOpt flatMap <span class=\"token punctuation\">{</span> i <span class=\"token keyword\">=></span>\n    jOpt flatMap <span class=\"token punctuation\">{</span> j <span class=\"token keyword\">=></span>\n      kOpt map <span class=\"token punctuation\">{</span> k <span class=\"token keyword\">=></span>\n        <span class=\"token keyword\">val</span> sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n        sum\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// for式で平坦化</span>\n<span class=\"token keyword\">val</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n  i <span class=\"token keyword\">&lt;-</span> iOpt <span class=\"token comment\">// #flatMap</span>\n  j <span class=\"token keyword\">&lt;-</span> jOpt <span class=\"token comment\">// #flatMap</span>\n  k <span class=\"token keyword\">&lt;-</span> kOpt <span class=\"token comment\">// #map</span>\n  sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">{</span>\n  sum\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// flatMapで平坦化した a と for式で平坦化した b は全く同じ</span>\nprintln<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span>\nprintln<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span></code></pre></div>\n<h3>関数シグネチャとして Option 型を使うべきか</h3>\n<p>関数シグネチャに Option 型は存在しない方が望ましいです。つまり、関数への入力値は必ず存在し、関数から返す値も必ず存在することが望ましいということです。ただし、実際にはプログラミングにおいて、一度でも Option 型に関わった場合、Option 型が付きまとうことがあります。そのため、関数の出力に Option 型が存在するのは一般的で、これは意図した例外が発生する可能性があることを示唆しています。一方、関数の入力に Option 型が存在する場合は、設計が適切でない可能性が高いです。</p>","frontmatter":{"title":"Scala言語のOption型の本質と使い方","date":"March 20, 2022","description":"Scala言語におけるOption型の基本的な使い方や、Option型を扱うためのコンビネーターについて解説しています。初心者が陥りやすい罠やコンビネーターの使い方についても詳しく説明しています。また、Scalaのfor式とflatMapの関係についても説明しています。","tags":["Scala"]}},"previous":null,"next":null},"pageContext":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3274528899"],"slicesMap":{}}