{"componentChunkName":"component---src-templates-blog-post-js","path":"/Scala言語のOption型の本質と使い方/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","excerpt":"Option型のポイント Option型の本質 プログラミング中でOption型に遭遇した場合は、次の2つの解釈ができます。1つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合はSomeとなり、値が存在しない場合はNoneとなります。…","html":"<h2>Option型のポイント</h2>\n<h3>Option型の本質</h3>\n<p>プログラミング中でOption型に遭遇した場合は、次の2つの解釈ができます。1つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合はSomeとなり、値が存在しない場合はNoneとなります。2つ目は、例外ハンドリング結果を表現したものです。正常に実行できた場合はSomeとなり、プログラムの実行中に意図した例外が発生した場合にNoneとなります。</p>\n<h3>単一のOption型の値に対して処理をしたいとき</h3>\n<p>初心者がやりがちなのは、Option型の値を取り出そうとすることですが、これは誤った発想です。代わりに、Option型の値を変換する発想が必要です。Option型の値を変換するには、mapコンビネーターを使用することで実現できます。また、他にもOption型から値を取り出さずに処理を行うコンビネーターが提供されていますので、こちらを使用することをおすすめします。ただし最終的にはどこかのタイミングでOption型から値を取り出す必要がありますが、可能な限りそのタイミングは遅らせるべきです。</p>\n<h3>複数のOption型の値に対して処理をしたいとき</h3>\n<p>初心者が陥りやすいのは、2つのOption型に対して処理をした結果、戻りの型が <code class=\"language-text\">Option[Option[T]]</code> のようにネストしてしまうことです。しかし、このネストしたものが表現するパターンは、以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側のOption</th>\n<th align=\"center\">内側のOption</th>\n<th align=\"center\">実質的に値があるかどうか</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">Some</td>\n<td align=\"center\">ある（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">None</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n<tr>\n<td align=\"center\">None</td>\n<td align=\"center\">-</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n<tr>\n<td align=\"center\">None</td>\n<td align=\"center\">-</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n</tbody>\n</table>\n<p>また、Option型には別の解釈方法もあり、最大要素数が1のコレクションとして捉えることができます。この場合、<code class=\"language-text\">Option[Option[T]]</code>の全体の要素数は以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側の要素数</th>\n<th align=\"center\">内側の要素数</th>\n<th align=\"center\">全体の要素数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0（None）</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0（None）</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0（None）</td>\n</tr>\n</tbody>\n</table>\n<p>つまり、実質的にはSomeかNoneの2通りしかありませんので、<code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> と平坦化することが望ましいです。この平坦化を実現するには、flatMapコンビネーターを使用することで簡単に実現できます。</p>\n<p>実務的には、まずはmapコンビネーターを使って処理をしてみて、戻り値が <code class=\"language-text\">Option[Option[T]]</code> のようになってしまった場合は、外側のmapをflatMapに変更することで解決できます。</p>\n<p>このように <code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> に変換できる性質を含めた抽象化された概念をモナドと呼びます。つまり、flatMapとはモナドという概念を表していることになります。</p>\n<h3>for式とflatMapの関係</h3>\n<p>初心者が誤解しやすいのは、Scalaのfor式をループ処理の指定だと勘違いしていることです。しかし、Scalaのfor式においてはその発想をまず捨ててください。for式の本質はflatMapの書き換えであり、ループ処理ではありません。flatMapの階層が深くなってきた場合には、for式に書き換えることをおすすめします。</p>\n<p>以下にOption型に対してfor式を適用した具体例を示します。</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> iOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> jOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> kOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// flatMapで平坦化</span>\n<span class=\"token keyword\">val</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  iOpt flatMap <span class=\"token punctuation\">{</span> i <span class=\"token keyword\">=></span>\n    jOpt flatMap <span class=\"token punctuation\">{</span> j <span class=\"token keyword\">=></span>\n      kOpt map <span class=\"token punctuation\">{</span> k <span class=\"token keyword\">=></span>\n        <span class=\"token keyword\">val</span> sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n        sum\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// for式で平坦化</span>\n<span class=\"token keyword\">val</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n  i <span class=\"token keyword\">&lt;-</span> iOpt <span class=\"token comment\">// #flatMap</span>\n  j <span class=\"token keyword\">&lt;-</span> jOpt <span class=\"token comment\">// #flatMap</span>\n  k <span class=\"token keyword\">&lt;-</span> kOpt <span class=\"token comment\">// #map</span>\n  sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">{</span>\n  sum\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// flatMapで平坦化した a と for式で平坦化した b は全く同じ</span>\nprintln<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span>\nprintln<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span></code></pre></div>\n<h3>関数シグネチャとしてOption型を使うべきか</h3>\n<p>関数シグネチャにOption型は存在しない方が望ましいです。つまり、関数への入力値は必ず存在し、関数から返す値も必ず存在することが望ましいということです。ただし、実際にはプログラミングにおいて、一度でもOption型に関わった場合、Option型が付きまとうことがあります。そのため、関数の出力にOption型が存在するのは一般的で、これは意図した例外が発生する可能性があることを示唆しています。一方、関数の入力にOption型が存在する場合は、設計が適切でない可能性が高いです。</p>","frontmatter":{"title":"Scala言語のOption型の本質と使い方","date":"March 20, 2022","description":"Scala言語におけるOption型の基本的な使い方や、Option型を扱うためのコンビネーターについて解説しています。初心者が陥りやすい罠やコンビネーターの使い方についても詳しく説明しています。また、Scalaのfor式とflatMapの関係についても説明しています。"}},"previous":null,"next":null},"pageContext":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3274528899"],"slicesMap":{}}