{"componentChunkName":"component---src-templates-blog-post-js","path":"/Scala言語のOption型の本質と使い方/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","excerpt":"Option 型のポイント Option 型の本質 プログラミング中に Option 型に遭遇した場合、次の 2 つの解釈ができます。1 つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合は Some となり、値が存在しない場合は None となります。…","html":"<h2>Option 型のポイント</h2>\n<h3>Option 型の本質</h3>\n<p>プログラミング中に Option 型に遭遇した場合、次の 2 つの解釈ができます。1 つ目は、ある値が存在するかどうかを表現したものです。これは単純に、値が存在する場合は Some となり、値が存在しない場合は None となります。2 つ目は、例外ハンドリング結果を表現したものです。正常に実行できた場合は Some となり、プログラムの実行中に意図した例外が発生した場合には None となります。</p>\n<p>Option 型を抽象化した概念の 1 つに、エフェクトを閉じ込めることができるエフェクトフルコンテキストがあります。エフェクトとは、例外などの副作用で関数の純粋性を欠く要素のことです。エフェクトフルコンテキストを導入することで、関数を純粋なものにすることが可能になります。ここで、例外は純粋性を損なうエフェクトであり、Option 型はそれを吸収する役割を担っています。つまり、Option 型の本質は、例外というエフェクトを吸収し純粋関数を作成するための手段であることです。</p>\n<h3>単一の Option 型の値に対して処理をしたいとき</h3>\n<p>初心者がやりがちなのは、Option 型の値を取り出そうとすることですが、これは誤った発想です。代わりに、Option 型の値を変換する発想が必要です。Option 型の値を変換するには、map コンビネーターを使用することで実現できます。また、他にも Option 型から値を取り出さずに処理を行うコンビネーターが提供されていますので、こちらを使用することをおすすめします。ただし最終的にはどこかのタイミングで Option 型から値を取り出す必要がありますが、可能な限りそのタイミングは遅らせるべきです。</p>\n<h3>複数の Option 型の値に対して処理をしたいとき</h3>\n<p>初心者が陥りやすいのは、2 つの Option 型に対して処理をした結果、戻りの型が <code class=\"language-text\">Option[Option[T]]</code> のようにネストしてしまうことです。しかし、このネストしたものが表現するパターンは、以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側の Option</th>\n<th align=\"center\">内側の Option</th>\n<th align=\"center\">実質的に値があるかどうか</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">Some</td>\n<td align=\"center\">ある（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">Some</td>\n<td align=\"center\">None</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n<tr>\n<td align=\"center\">None</td>\n<td align=\"center\">-</td>\n<td align=\"center\">ない（None）</td>\n</tr>\n</tbody>\n</table>\n<p>また、Option 型には別の解釈方法もあり、最大要素数が 1 のコレクションとして捉えることができます。この場合、<code class=\"language-text\">Option[Option[T]]</code>の全体の要素数は以下のとおりです。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">外側の要素数</th>\n<th align=\"center\">内側の要素数</th>\n<th align=\"center\">全体の要素数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1（Some）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0（None）</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0（None）</td>\n</tr>\n</tbody>\n</table>\n<p>つまり、実質的には Some か None の 2 通りしかありませんので、<code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> と平坦化することが望ましいです。この平坦化を実現するには、flatMap コンビネーターを使用することで簡単に実現できます。</p>\n<p>実務的には、まずは map コンビネーターを使って処理をしてみて、戻り値が <code class=\"language-text\">Option[Option[T]]</code> のようになってしまった場合は、外側の map を flatMap に変更することで解決できます。</p>\n<p>このように <code class=\"language-text\">Option[Option[T]]</code> を <code class=\"language-text\">Option[T]</code> に変換できる性質を含めた抽象化された概念をモナドと呼びます。つまり、flatMap とはモナドという概念を表していることになります。</p>\n<h3>for 式と flatMap の関係</h3>\n<p>初心者が誤解しやすいのは、Scala の for 式をループ処理の指定だと勘違いしていることです。しかし、Scala の for 式においてはその発想をまず捨ててください。for 式の本質は flatMap の書き換えであり、ループ処理ではありません。flatMap の階層が深くなってきた場合には、for 式に書き換えることをおすすめします。</p>\n<p>以下に Option 型に対して for 式を適用した具体例を示します。</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> iOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> jOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> kOpt <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// flatMapで平坦化</span>\n<span class=\"token keyword\">val</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  iOpt flatMap <span class=\"token punctuation\">{</span> i <span class=\"token keyword\">=></span>\n    jOpt flatMap <span class=\"token punctuation\">{</span> j <span class=\"token keyword\">=></span>\n      kOpt map <span class=\"token punctuation\">{</span> k <span class=\"token keyword\">=></span>\n        <span class=\"token keyword\">val</span> sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n        sum\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// for式で平坦化</span>\n<span class=\"token keyword\">val</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n  i <span class=\"token keyword\">&lt;-</span> iOpt <span class=\"token comment\">// #flatMap</span>\n  j <span class=\"token keyword\">&lt;-</span> jOpt <span class=\"token comment\">// #flatMap</span>\n  k <span class=\"token keyword\">&lt;-</span> kOpt <span class=\"token comment\">// #map</span>\n  sum <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> j <span class=\"token operator\">+</span> k\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">{</span>\n  sum\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// flatMapで平坦化した a と for式で平坦化した b は全く同じ</span>\nprintln<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span>\nprintln<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some(6)</span></code></pre></div>\n<h3>Option 型に対してパターンマッチングを使うべきか</h3>\n<p>原則として、Option 型に対してパターンマッチングを使用するべきではありませんが、柔軟な条件分岐が要求される場合は例外となります。Option 型には様々なコンビネータが用意されており、計算結果の合成が容易で、チェーン操作により直感的な実装が可能であり、可読性が向上します。一方で、簡単なシチュエーションでパターンマッチングを使用すると、冗長なコードになり可読性が低下することがあります。</p>\n<p>以下は、典型的な悪いコード例です。</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> opt<span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Some<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\nopt <span class=\"token keyword\">match</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> Some<span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> None <span class=\"token keyword\">=></span> None\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>関数シグネチャとして Option 型を使うべきか</h3>\n<p>関数シグネチャに Option 型は存在しない方が望ましいです。つまり、関数への入力値は必ず存在し、関数から返す値も必ず存在することが望ましいということです。ただし、実際にはプログラミングにおいて、一度でも Option 型に関わった場合、Option 型が付きまとうことがあります。そのため、関数の出力に Option 型が存在するのは一般的で、これは意図した例外が発生する可能性があることを示唆しています。一方、関数の入力に Option 型が存在する場合は、設計が適切でない可能性が高いです。</p>\n<h2>おわりに</h2>\n<p>本記事では、Option 型について説明しましたが、抽象化された概念は他の型（Future 型など）にも適用できるため、これらの型の役割や取り扱い方法を理解するためにも重要です。</p>","frontmatter":{"title":"Scala初心者必見！Option型の本質と基本操作","date":"March 20, 2023","description":"Scala言語でのOption型の基本的な使い方や理解のためのポイントを解説します。初心者向けに分かりやすく説明し、Option型を効果的に利用するためのコツも紹介しています。","tags":["Scala"]}},"previous":null,"next":{"fields":{"slug":"/Scala_basic_exercise_for_beginners/"},"frontmatter":{"title":"Scala言語の基礎確認用練習問題"}}},"pageContext":{"id":"c0ba5085-a1da-55c8-9d74-c1c46f2448ed","previousPostId":null,"nextPostId":"7d8b63cd-385e-5351-a886-f52ba26f1729"}},"staticQueryHashes":["3000541721","3274528899"],"slicesMap":{}}